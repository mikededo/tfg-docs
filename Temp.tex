% !TeX spellcheck = en_GB 

\documentclass[a4paper, 12pt, oneside]{book}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[pagestyles]{titlesec}
\usepackage{titletoc}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage[a4paper, margin = 2.5cm, headheight=14pt]{geometry}
\usepackage[hidelinks, colorlinks = false]{hyperref}
\usepackage[bottom]{footmisc}
\usepackage{bookmark}
\usepackage{fontspec}
\usepackage{graphicx}
\usepackage[labelfont = bf]{caption}
\usepackage{etoolbox}
\usepackage{tabularx}
\usepackage{colortbl}
\usepackage{float}

\usepackage[table]{xcolor}

\title{
	\includegraphics[width=0.75\textwidth]{assets/logo.png}
	\\
	{\huge Hubbl, a gym bookings manager}
}
\author{Miquel de Domingo i Giralt}

\setmainfont{Inter}[BoldFont = Inter Bold]
\setmonofont[Scale=0.9]{JetBrains Mono}

\newfontfamily\semibf{Inter Semi Bold}

% Variable with the page that keeps the footer style
\def\footerstyle{- \fontsize{10pt}{10pt}\selectfont\thepage\ -}
\pagestyle{fancy}
% Remove the horizontal bar from the header
\renewcommand{\headrulewidth}{0pt}
% Clear everythihg
\fancyhf{}
% Set header style
\rhead{\small\textit{\nouppercase{\rightmark}}}
% Set the footer page number
\fancyfoot[C]{\footerstyle}
% Update the footer in chapter and other plain views
\fancypagestyle{plain}{%
    \renewcommand{\headrulewidth}{0pt}%
    \fancyhf{}%
    \fancyfoot[C]{\footerstyle}%
}

\setlength\parindent{0pt}
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}

% Tables format
\definecolor{rowColor}{RGB}{242, 242, 242}
\renewcommand{\arraystretch}{1.5}

\titleformat{\chapter}[hang]{\normalfont\huge\bfseries}{\thechapter. }{4pt}{\Huge}
\titlespacing{\chapter}{0pt}{-32pt}{12pt}

\begin{document}
\frontmatter
\maketitle
\mainmatter
\chapter{Implementation and trials}
\section{Introduction}
The goal of this chapter is to explain the development process, from the thinking of the application and its structure, to the actual development of it. It will also include and explanation of how the application has been constantly tested\footnotetext{Most testing involves unit and integration testing. In the API application, end-to-end testing has been implemented. For the UI applications, do not have end-to-end testing implemented due to a lack of time}.
\section{Organizing the idea}
When I came up with the idea for the application, I ended up with a mix of thoughts that had to be organized and connected. Therefore, the first step was to write an extensive explanation of the application, the goal of the application, what it would do and what it would not do, trying to cover as many details as I could. After revising and rethinking the idea, I ended up with a potential project that \emph{made sense} and could provide value to future clients.
\\[8pt]
Once the application had been described, defining the functionalities of such were easier. However, I needed to define a possible structure for such application. It was then when I decided to develop three applications: the landing page, the core application and the client application. I found interesting to distinguish between the client and the core application in order to simplify the development process. Mostly, when an application is expected to cover the most amount of possibilities and users, it ends which an enourmous amounts of checks and even repeated code. Knowing so, I decided to split it in two applications, while at the same time reducing the amount of boilerplate code. Knowing the existence of Nx, I had the logistic problem of maintaining a monorepo with the applications and libraries solved by such tool.
\\[8pt]
Even though it would probably change in structure, the initial idea of the architecture was there, and from it, I could start specifying the functional and non-functional requirements. It was probably the most time demanding task of the project, alongside structuring the working packages. Now that such parts were defined, I was able to visualise a roadmap for the development of the system.
\section{Application development}
I started developing the API application as it helped to define the database. It ended up being the most repetitive project to develop as there are many endpoints which are quite similar, however others were such a challenge, as involved complex queries. Once the server had been ``finished''\footnotetext{It is hard to consider a project finished, as product applications need constant improvements and changes in order to keep up with the market.}, I started designing the user interface. knowing available endpoints of the server helped with the thingking of the UI, yet at the same time it helped me realise what was lacking in the server. Therefore, after having finished the design, I got back to the API, adding what was mssing and cleaning up the code\footnotetext{Such thing was also expected in the roadmap, as it was my intention to revise the server after designing the UI.}.
\\[8pt]
The next step was to start developing the UI applications. The core application had the most amount of logic and difficulty, which is the reason why I started with such project. I knew I would have to add a lot of components and views which would later be reused in the client application. This is the reason why the working packages for the core application have more estimated time than the client application. With Nx has been extremely easy and simple to abstract common code and keep it in the shared libraries, which can be easily used and referenced in any application. If in the future it is needed to add another application, the development process would be extremely simple, since most components could be reused.
\\[8pt]
Since then, I have been developing most of the core application. When most of it had been finished, I started developing the client application. With it, I had to start abstracting some of the code that was in the core application, so that it can be reused.
\subsection{Continuous integration}
One of the things that I explained in previous sections was the importance of having continuous integration, which would help to know if the code developed would cause errors or not. Also, with integration tests, it would be easier to verify if the component or controller work as expected. It was also one of the reasons why I chose Nx as a build tool, as it allows you to test for a specific project.
%One of the CLI tools it provides is the \texttt{affected} command. Such command checks which projects have been changed and run commands to such projects.
\\[8pt]
%TODO: https://docs.github.com/en/actions/using-workflows 22/05/2022
Knowing so, I defined multiple workflows which would run if there were changes in the different project directiories\footnotetext{GitHub worflows allow you to trigger worflows on changes made in a given folder path.}. The worflows would be run in two conditions:
\begin{enumerate}
	\item If there is a push in the \texttt{develop} branch.
	\item If a pull request if opened.
\end{enumerate}
The development process would be:
\begin{enumerate}
	\item Creating a branch with the name of the Jira issue. Using such naming convention, when accessing an issue in Jira, it was easier to find the issue branches.
	\item Adding as many changes as wanted, while also adding tests. If the changes were added in the API application, it should include unit, integration and e2e tests. If the changes where added in any library of any UI application, it should include unit and integration tests.
 \item Once the task has been finished, a PR should be created which would trigger the workflows.
 \item If all checks pass, the PR can be merged into the wanted branch.
\end{enumerate}
Using the PRs, it becomes really easy to identify issues, and it ensures that not a single line of coded is merged without knowing it does not pass its tests. As an addition to the checks, I also integrated CodeCov, which is a freemium tool that helps to visualise the coverage of the project\footnotetext{The CodeCov configuration file can be found in the \texttt{codecov.yaml} in the root folder of the repository.}. The CodeCov integration adds a comment to the pull request summarizing the changes made and how such changes modify the coverage of the project.
% TODO: Add CodeCov image
\\[8pt] 
As explained before, the API server runs an e2e test. Such test requires a fake database and also takes more time to initialise, run and finish. Therefore, the end-to-end tests are not run on every merge to develop or every PR, but when the code is merged to the \texttt{main} branch. The end-to-end test starts a docker container in the GitHub action that will contain the database which will be used by the tests.
\end{document}